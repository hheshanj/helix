import {
  createContext,
  getAbortSignal,
  getAllContexts,
  getContext,
  get_render_context,
  get_user_code_location,
  hasContext,
  hydratable_clobbering,
  hydratable_serialization_failed,
  lifecycle_function_unavailable,
  setContext,
  ssr_context,
  uneval
} from "./chunk-SICCU2IJ.js";
import "./chunk-7NRLI5RA.js";
import {
  experimental_async_required,
  noop,
  run
} from "./chunk-GBY57JXA.js";
import {
  dev_fallback_default
} from "./chunk-XVVR3IV4.js";
import {
  async_mode_flag
} from "./chunk-OHYQYV5R.js";
import "./chunk-MZQ22LAU.js";

// node_modules/svelte/src/internal/server/hydratable.js
function hydratable(key, fn) {
  if (!async_mode_flag) {
    experimental_async_required("hydratable");
  }
  const { hydratable: hydratable2 } = get_render_context();
  let entry = hydratable2.lookup.get(key);
  if (entry !== void 0) {
    if (dev_fallback_default) {
      const comparison = compare(key, entry, encode(key, fn()));
      comparison.catch(() => {
      });
      hydratable2.comparisons.push(comparison);
    }
    return (
      /** @type {T} */
      entry.value
    );
  }
  const value = fn();
  entry = encode(key, value, hydratable2.unresolved_promises);
  hydratable2.lookup.set(key, entry);
  return value;
}
function encode(key, value, unresolved) {
  const entry = { value, serialized: "" };
  if (dev_fallback_default) {
    entry.stack = get_user_code_location();
  }
  let uid = 1;
  entry.serialized = uneval(entry.value, (value2, uneval2) => {
    if (is_promise(value2)) {
      const placeholder = `"${uid++}"`;
      const p = value2.then((v) => {
        entry.serialized = entry.serialized.replace(placeholder, `r(${uneval2(v)})`);
      }).catch(
        (devalue_error) => hydratable_serialization_failed(
          key,
          serialization_stack(entry.stack, devalue_error == null ? void 0 : devalue_error.stack)
        )
      );
      unresolved == null ? void 0 : unresolved.set(p, key);
      p.catch(() => {
      }).finally(() => unresolved == null ? void 0 : unresolved.delete(p));
      (entry.promises ?? (entry.promises = [])).push(p);
      return placeholder;
    }
  });
  return entry;
}
function is_promise(value) {
  return Object.prototype.toString.call(value) === "[object Promise]";
}
async function compare(key, a, b) {
  for (const p of (a == null ? void 0 : a.promises) ?? []) {
    await p;
  }
  for (const p of (b == null ? void 0 : b.promises) ?? []) {
    await p;
  }
  if (a.serialized !== b.serialized) {
    const a_stack = (
      /** @type {string} */
      a.stack
    );
    const b_stack = (
      /** @type {string} */
      b.stack
    );
    const stack = a_stack === b_stack ? `Occurred at:
${a_stack}` : `First occurrence at:
${a_stack}

Second occurrence at:
${b_stack}`;
    hydratable_clobbering(key, stack);
  }
}
function serialization_stack(root_stack, uneval_stack) {
  let out = "";
  if (root_stack) {
    out += root_stack + "\n";
  }
  if (uneval_stack) {
    out += "Caused by:\n" + uneval_stack + "\n";
  }
  return out || "<missing stack trace>";
}

// node_modules/svelte/src/internal/server/blocks/snippet.js
function createRawSnippet(fn) {
  return (renderer, ...args) => {
    var getters = (
      /** @type {Getters<Params>} */
      args.map((value) => () => value)
    );
    renderer.push(
      fn(...getters).render().trim()
    );
  };
}

// node_modules/svelte/src/index-server.js
function onDestroy(fn) {
  /** @type {SSRContext} */
  ssr_context.r.on_destroy(fn);
}
function createEventDispatcher() {
  return noop;
}
function mount() {
  lifecycle_function_unavailable("mount");
}
function hydrate() {
  lifecycle_function_unavailable("hydrate");
}
function unmount() {
  lifecycle_function_unavailable("unmount");
}
function fork() {
  lifecycle_function_unavailable("fork");
}
async function tick() {
}
async function settled() {
}
export {
  noop as afterUpdate,
  noop as beforeUpdate,
  createContext,
  createEventDispatcher,
  createRawSnippet,
  noop as flushSync,
  fork,
  getAbortSignal,
  getAllContexts,
  getContext,
  hasContext,
  hydratable,
  hydrate,
  mount,
  onDestroy,
  noop as onMount,
  setContext,
  settled,
  tick,
  unmount,
  run as untrack
};
//# sourceMappingURL=svelte.js.map
