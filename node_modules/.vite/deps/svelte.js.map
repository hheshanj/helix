{
  "version": 3,
  "sources": ["../../svelte/src/internal/server/hydratable.js", "../../svelte/src/internal/server/blocks/snippet.js", "../../svelte/src/index-server.js"],
  "sourcesContent": ["/** @import { HydratableLookupEntry } from '#server' */\nimport { async_mode_flag } from '../flags/index.js';\nimport { get_render_context } from './render-context.js';\nimport * as e from './errors.js';\nimport * as devalue from 'devalue';\nimport { get_stack } from '../shared/dev.js';\nimport { DEV } from 'esm-env';\nimport { get_user_code_location } from './dev.js';\n\n/**\n * @template T\n * @param {string} key\n * @param {() => T} fn\n * @returns {T}\n */\nexport function hydratable(key, fn) {\n\tif (!async_mode_flag) {\n\t\te.experimental_async_required('hydratable');\n\t}\n\n\tconst { hydratable } = get_render_context();\n\n\tlet entry = hydratable.lookup.get(key);\n\n\tif (entry !== undefined) {\n\t\tif (DEV) {\n\t\t\tconst comparison = compare(key, entry, encode(key, fn()));\n\t\t\tcomparison.catch(() => {});\n\t\t\thydratable.comparisons.push(comparison);\n\t\t}\n\n\t\treturn /** @type {T} */ (entry.value);\n\t}\n\n\tconst value = fn();\n\n\tentry = encode(key, value, hydratable.unresolved_promises);\n\thydratable.lookup.set(key, entry);\n\n\treturn value;\n}\n\n/**\n * @param {string} key\n * @param {any} value\n * @param {Map<Promise<any>, string>} [unresolved]\n */\nfunction encode(key, value, unresolved) {\n\t/** @type {HydratableLookupEntry} */\n\tconst entry = { value, serialized: '' };\n\n\tif (DEV) {\n\t\tentry.stack = get_user_code_location();\n\t}\n\n\tlet uid = 1;\n\n\tentry.serialized = devalue.uneval(entry.value, (value, uneval) => {\n\t\tif (is_promise(value)) {\n\t\t\t// we serialize promises as `\"${i}\"`, because it's impossible for that string\n\t\t\t// to occur 'naturally' (since the quote marks would have to be escaped)\n\t\t\t// this placeholder is returned synchronously from `uneval`, which includes it in the\n\t\t\t// serialized string. Later (at least one microtask from now), when `p.then` runs, it'll\n\t\t\t// be replaced.\n\t\t\tconst placeholder = `\"${uid++}\"`;\n\t\t\tconst p = value\n\t\t\t\t.then((v) => {\n\t\t\t\t\tentry.serialized = entry.serialized.replace(placeholder, `r(${uneval(v)})`);\n\t\t\t\t})\n\t\t\t\t.catch((devalue_error) =>\n\t\t\t\t\te.hydratable_serialization_failed(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tserialization_stack(entry.stack, devalue_error?.stack)\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tunresolved?.set(p, key);\n\t\t\t// prevent unhandled rejections from crashing the server, track which promises are still resolving when render is complete\n\t\t\tp.catch(() => {}).finally(() => unresolved?.delete(p));\n\n\t\t\t(entry.promises ??= []).push(p);\n\t\t\treturn placeholder;\n\t\t}\n\t});\n\n\treturn entry;\n}\n\n/**\n * @param {any} value\n * @returns {value is Promise<any>}\n */\nfunction is_promise(value) {\n\t// we use this check rather than `instanceof Promise`\n\t// because it works cross-realm\n\treturn Object.prototype.toString.call(value) === '[object Promise]';\n}\n\n/**\n * @param {string} key\n * @param {HydratableLookupEntry} a\n * @param {HydratableLookupEntry} b\n */\nasync function compare(key, a, b) {\n\t// note: these need to be loops (as opposed to Promise.all) because\n\t// additional promises can get pushed to them while we're awaiting\n\t// an earlier one\n\tfor (const p of a?.promises ?? []) {\n\t\tawait p;\n\t}\n\n\tfor (const p of b?.promises ?? []) {\n\t\tawait p;\n\t}\n\n\tif (a.serialized !== b.serialized) {\n\t\tconst a_stack = /** @type {string} */ (a.stack);\n\t\tconst b_stack = /** @type {string} */ (b.stack);\n\n\t\tconst stack =\n\t\t\ta_stack === b_stack\n\t\t\t\t? `Occurred at:\\n${a_stack}`\n\t\t\t\t: `First occurrence at:\\n${a_stack}\\n\\nSecond occurrence at:\\n${b_stack}`;\n\n\t\te.hydratable_clobbering(key, stack);\n\t}\n}\n\n/**\n * @param {string | undefined} root_stack\n * @param {string | undefined} uneval_stack\n */\nfunction serialization_stack(root_stack, uneval_stack) {\n\tlet out = '';\n\tif (root_stack) {\n\t\tout += root_stack + '\\n';\n\t}\n\tif (uneval_stack) {\n\t\tout += 'Caused by:\\n' + uneval_stack + '\\n';\n\t}\n\treturn out || '<missing stack trace>';\n}\n", "/** @import { Snippet } from 'svelte' */\n/** @import { Renderer } from '../renderer' */\n/** @import { Getters } from '#shared' */\n\n/**\n * Create a snippet programmatically\n * @template {unknown[]} Params\n * @param {(...params: Getters<Params>) => {\n *   render: () => string\n *   setup?: (element: Element) => void | (() => void)\n * }} fn\n * @returns {Snippet<Params>}\n */\nexport function createRawSnippet(fn) {\n\t// @ts-expect-error the types are a lie\n\treturn (/** @type {Renderer} */ renderer, /** @type {Params} */ ...args) => {\n\t\tvar getters = /** @type {Getters<Params>} */ (args.map((value) => () => value));\n\t\trenderer.push(\n\t\t\tfn(...getters)\n\t\t\t\t.render()\n\t\t\t\t.trim()\n\t\t);\n\t};\n}\n", "/** @import { SSRContext } from '#server' */\n/** @import { Renderer } from './internal/server/renderer.js' */\nimport { ssr_context } from './internal/server/context.js';\nimport { noop } from './internal/shared/utils.js';\nimport * as e from './internal/server/errors.js';\n\n/** @param {() => void} fn */\nexport function onDestroy(fn) {\n\t/** @type {Renderer} */ (/** @type {SSRContext} */ (ssr_context).r).on_destroy(fn);\n}\n\nexport {\n\tnoop as beforeUpdate,\n\tnoop as afterUpdate,\n\tnoop as onMount,\n\tnoop as flushSync,\n\trun as untrack\n} from './internal/shared/utils.js';\n\nexport function createEventDispatcher() {\n\treturn noop;\n}\n\nexport function mount() {\n\te.lifecycle_function_unavailable('mount');\n}\n\nexport function hydrate() {\n\te.lifecycle_function_unavailable('hydrate');\n}\n\nexport function unmount() {\n\te.lifecycle_function_unavailable('unmount');\n}\n\nexport function fork() {\n\te.lifecycle_function_unavailable('fork');\n}\n\nexport async function tick() {}\n\nexport async function settled() {}\n\nexport { getAbortSignal } from './internal/server/abort-signal.js';\n\nexport {\n\tcreateContext,\n\tgetAllContexts,\n\tgetContext,\n\thasContext,\n\tsetContext\n} from './internal/server/context.js';\n\nexport { hydratable } from './internal/server/hydratable.js';\n\nexport { createRawSnippet } from './internal/server/blocks/snippet.js';\n"],
  "mappings": "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",
  "names": ["hydratable", "value", "uneval"]
}
